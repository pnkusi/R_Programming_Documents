---
title: "Class 3"
output: html_document
date: "2025-10-16"
---

#  Control structures

# Grouping
# Control structures in R allow you to control the flow of execution of a series of R expressions. Basically, control structures allow you to put some “logic” into your Rcode, rather than just always executing the same R code every time. Control structures allow you to respond to inputs or to features of the data and execute different R expressions accordingly. Commonly used control structures are 
# • if and else: testing a condition and acting on it 
#• for: execute a loop a fixed number of times
# • while: execute a loop while a condition is true 
# • repeat: execute an infinite loop (must break out of it to stop) 
# • break: break the execution of a loop 
# • next: skip an interaction of a loop
# if (condition){ ## do something } ## continue with the rest of the code.
# if( condition){ do something
# } else { do something else}

#You can also create a series of test by following the initial if with a number of else ifs
#if(condition){ do something
# }else if (condition 2){ Do something different }else{ do something different }


# Function on R
```{r}
f<-function(x) x^2
formals(f)
```

```{r}
body(f)
```
```{r}
environment(f)

```

# ifelse(test,yes,No)

```{r}
pvalues<-c(.867,0.0054,0.0018,0.1572,0.0183,0.5386)
results<-ifelse(pvalues<0.05,"Significant"," Not significant")
results
```

```{r}
x<-runif(1,0,10)
if(x>3){
y<-10
}else {
y<-0
}
```

# The value of y is a set depend ingon whether x>3 or not.This can also be achieved by
```{r}
x<-runif(1,0,10)
 if(x>3){
 y<-10
 }else{
 y<-0
 }
```


```{r}
for(i in 1:10){
print(i)}
```


```{r}
x<-c("a","b","c","d")
x
```

```{r}
x[3]
```

```{r}
for(i in 1:5){
print(x[i])
}
```

```{r}
for(i in 1:5)print(1:i)
```

```{r}
for(i in 5:1)print(1:i)
```

# while Loops
 
#It begins by testing acondition,if it is true,then they execute the loop body. once the loop body is executed,the condition is tested again, until the condition is false.after which the loop exits.
```{r}
count<-1
while (count<10){
print(count)
count<-count+1
}
```
```{r}
z<-5
set.seed(1)
while(z>= 3 && z<=10){
coin<-rbinom(1,1,0.5)
if (coin==1){
z=z+1
} else {
z<-z-1
}
}
print(z)
```

# next,break

 This is used to skip an iteration of a loop
 
```{r}
for (i in 1:100){
print(1:i)
if (i>20){
break
}
}
```
# Function

 functionname<-function(parameters){statements return(value)}
 f1<-function(x){result <- x^2+2 return (result)}
 f2<-function(x,y){result <- x2+y2-4 return (result)}


```{r}
f1 <- function(x) {
  result <- x^2 + 2
  return(result)
}

f2 <- function(x, y) {
  result <- x^2 + y^2 - 4
  return(result)
}

f <- function(x, y) {
  result <- x + (2 * y) + 3
  return(result)
}

```


```{r}
f(2,3)
```
You can use args() function to view the parameter names and default values

#Exercises

 Make functions that calculate summary statistics
 Make a function to calculate two samplet test
 Applying functions to matrices and dataframe

```{r}
a<-4
sqrt(4)
## [1] 2
b<- c(1,243,5.754,2.987)
round(b)
```

```{r}
c<-matrix(runif(12),nrow=3)
c
```

```{r}
log(c)
```

```{r}
mean(c)
```

Notice that the mean of matrix c results in ascalar(0.444).
 the mean()take the average of all 12 elements in the matrix.
 But what if you want the three rowmeans or the four column means?
 
 R provides afunction, apply() that allows to apply an arbitrary function to any dimension of amatrix, array or dataframe. 
The format for the apply()function is

apply(x, MARGIN, FUN,…) where x stands for the data object, Margin can be 1(rows)
 and 2(columns ) ##Col/Row Sums and Means
 • rowSums=apply(x, 1, sum) • rowMeans= apply(x, 1, mean)• colSums =apply(x, 2,
 sum)
 •colMeans= apply(x, 2, mean)
 
# lappy function

 lapply() takes three inputs:,x,a list,a function, and…, It applies to each element of the
 list and returns a new list. lapply(x,f,…). It is called function because it takes function
 as an argument. 
 Assume we have a dataframe df. instead of assigning the result pf
 lappliy() to df, we will assign them to df[] to ensure we get a data frame.
 
```{r}
fix_missing<-function(x){
x[x==-99]<-NA
x
}
function1<-function(x){
x^2
}
curve(function1,-4,4)
```
It works for any number of columns.There is no way to accidentally miss a column
There is no way to accidentally treat one column differently than another
 It easy to generalize this technique to a subset of columns
 
 
#sapply
 sapply() and vapply(),variants of lapply() that produces vectors,matrices,and
 arrays as Output,instead of lists map(),and apply which iterate over multiple
 in put data structures in parallel
 Another important function when dealing with big data is split()-tapply
# Titanic data

```{r}
str(Titanic)
```

```{r}
View(Titanic)
apply(Titanic,c(1,2),sum )
```
```{r}
options(digits = 2)
apply(Titanic,c(1,2),sum)[3:4,]
```

```{r}
apply(Titanic,c(1,4),sum)[3:4,]
```

```{r}
apply(Titanic,c(1,2,4),sum)
```

```{r}
apply(Titanic,c(1,2,4),sum)[3:4,,]
```
```{r}
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])
```

```{r}
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,]
```

```{r}
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,]
```

```{r}
digit=2
prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,], margin = 2)
```

```{r}
prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,], margin = 2)
```
```{r}

tab <- apply(Titanic, c(1, 4, 2), sum)   
tab_sub <- tab[3:4, , ]                   
ftab <- ftable(tab_sub)[1:2, ]           
prop_tab <- prop.table(ftab, margin = 2) 

result <- matrix(prop_tab, nrow = 2,
                 dimnames = list(dimnames(Titanic)$Survived,
                                 dimnames(Titanic)$Sex))

result

```
```{r}

tab <- apply(Titanic, c(1, 4, 2), sum)

tab_sub <- tab[3:4, , ]
ftab <- ftable(tab_sub)[3:4, ]

prop_tab <- prop.table(ftab, margin = 2)
result <- matrix(prop_tab, nrow = 2,
                 dimnames = list(dimnames(Titanic)$Survived,
                                 dimnames(Titanic)$Sex))

result

```
```{r}
###Createdataset

Student <- c("John ncuti", "Angela bakame", "Bruce wizeye", "Alexis aganze", 
             "claude Rukundo", "Joel Kagabo", "Mary ineza")
Math <- c(600, 412, 358, 495, 512, 410, 522)
Science <- c(95, 99, 80, 82, 75, 89, 77)
English <- c(25, 22, 18, 20, 29, 30, 27)

roster <- data.frame(Student, Math, Science, English, stringsAsFactors = FALSE)

str(roster)

```
```{r}
###standardize variables and obtains the performance scores because they are reported on different scale (With widely differing means and standard deviations,we need to make them comparable before we combine them.)
z<-scale(roster[,2:4])
z
```

```{r}
###performance of each students using rowmeans and adding them to roster using cbind()
score<-apply(z,1,mean)
roster<-cbind(roster,score)
roster
```

```{r}

###Grades the students:quantile function gives the percentile rank of each student's performance score check the cut off of A

y<-quantile(score,c(.8,.6,.4,.2))
y
```

```{r}
## create a grade variable us
roster$grade[score>=y[1]]<-"A"
roster$grade[score<y[1]&score>=y[2]]<-"B"
roster$grade[score<y[2]& score>=y[3]]<-"C"
roster$grade[score<y[3]& score>=y[4]]<-"D"
roster$grade[score<y[4]]<-"F"
roster
```

```{r}
#### Dealing with names
name<-strsplit((roster$Student),"")
lastname<-sapply (name,"[",2)
firstname<-sapply(name,"[",1)
roster<-cbind(firstname, lastname,roster[,-1])
roster<-roster[order(lastname,firstname),]
roster
```
# Aggregation and reshaping

# Transpose

```{r}
cars<-mtcars[1:5, 1:4]
cars
```

```{r}
t(cars)
```
# aggregate data
 aggregate() collapse data in R using one or more by variables and a defined function
 
```{r}
options(digits=3)
attach(mtcars)
aggdata<-aggregate(mtcars,by=list(cyl,gear),FUN=mean,na.rm=TRUE)
```
# Reshape
 
 Step 1: install the package reshape2 step 2: melt data step 3: Cast the melted data into any shape you desire
 During the cast, you can aggregate the data with any function you wish


```{r}
id<-c(1,1,2,2)
time<-c(1,2,1,2)
x1<-c(5,3,6,2)
x2<-c(6,5,1,4)
mydata<-data.frame(id,time,x1,x2)
mydata
```

```{r}

```

